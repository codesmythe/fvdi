#include "xosera.h"

void xosera_palette_register_write(volatile xmreg_t *const xosera_ptr, uint8_t palette, uint16_t data)
{
    xm_setw(WR_XADDR, XR_COLOR_ADDR | palette);
    xm_setw(XDATA, data);
}

// A lookup table to take a color in 4 bits and expand it to sixteen, e.g A => 0xAAAA
uint16_t expanded_color[16] = {
        0x0000, 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777,
        0x8888, 0x9999, 0xAAAA, 0xBBBB, 0xCCCC, 0xDDDD, 0xEEEE, 0xFFFF
};

// Various debug routines below here

#ifdef FVDI_DEBUG

#include "driver.h"

const char *mode2string(long mode)
{
    switch (mode) {
        case 1:
            return "Replace";
        case 2:
            return "Transparent";
        case 3:
            return "XOR";
        case 4:
            return "Reverse Transparent";
        default:
            return "Unknown";
    }
}

const char *operation2string(long operation)
{
    switch (operation) {
        case 0:
            return "D' = 0 (clear)";
        case 1:
            return "D' = S AND D";
        case 2:
            return "D' = S AND (NOT D)";
        case 3:
            return "D' = S (replace)";
        case 4:
            return "D' = (NOT S) AND D (erase)";
        case 5:
            return "D' = D  (dest unchaned)";
        case 6:
            return "D' = S XOR D (XOR mode)";
        case 7:
            return "D' = S OR D (transparent mode)";
        case 8:
            return "D' = NOT (S OR D)";
        case 9:
            return "D' = NOT (S XOR D)";
        case 10:
            return "D' = NOT D";
        case 11:
            return "D' = S OR (NOT D)";
        case 12:
            return "D' = NOT S";
        case 13:
            return "D' = (NOT S) OR D (reverse transparent mode)";
        case 14:
            return "D' = NOT (S AND D)";
        case 15:
            return "D' = 1 (fill dest)";
        default:
            return "unknown";
    }
}

static unsigned short patterns[][16] = {
        {0x0000, 0x4444, 0x0000, 0x1111, 0x0000, 0x4444, 0x0000, 0x1111,
                0x0000, 0x4444, 0x0000, 0x1111, 0x0000, 0x4444, 0x0000, 0x1111},
        {0x0000, 0x5555, 0x0000, 0x5555, 0x0000, 0x5555, 0x0000, 0x5555,
                0x0000, 0x5555, 0x0000, 0x5555, 0x0000, 0x5555, 0x0000, 0x5555},
        {0x8888, 0x5555, 0x2222, 0x5555, 0x8888, 0x5555, 0x2222, 0x5555,
                0x8888, 0x5555, 0x2222, 0x5555, 0x8888, 0x5555, 0x2222, 0x5555},
        {0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555,
                0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555},
        {0xaaaa, 0xdddd, 0xaaaa, 0x7777, 0xaaaa, 0xdddd, 0xaaaa, 0x7777,
                0xaaaa, 0xdddd, 0xaaaa, 0x7777, 0xaaaa, 0xdddd, 0xaaaa, 0x7777},
        {0xaaaa, 0xffff, 0xaaaa, 0xffff, 0xaaaa, 0xffff, 0xaaaa, 0xffff,
                0xaaaa, 0xffff, 0xaaaa, 0xffff, 0xaaaa, 0xffff, 0xaaaa, 0xffff},
        {0xeeee, 0xffff, 0xbbbb, 0xffff, 0xeeee, 0xffff, 0xbbbb, 0xffff,
                0xeeee, 0xffff, 0xbbbb, 0xffff, 0xeeee, 0xffff, 0xbbbb, 0xffff},
        {0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
                0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
        {0xffff, 0x8080, 0x8080, 0x8080, 0xffff, 0x0808, 0x0808, 0x0808,
                0xffff, 0x8080, 0x8080, 0x8080, 0xffff, 0x0808, 0x0808, 0x0808},
        {0x2020, 0x4040, 0x8080, 0x4141, 0x2222, 0x1414, 0x0808, 0x1010,
                0x2020, 0x4040, 0x8080, 0x4141, 0x2222, 0x1414, 0x0808, 0x1010},
        {0x0000, 0x0000, 0x1010, 0x2828, 0x0000, 0x0000, 0x0101, 0x8282,
                0x0000, 0x0000, 0x1010, 0x2828, 0x0000, 0x0000, 0x0101, 0x8282},
        {0x0202, 0x0202, 0xaaaa, 0x5050, 0x2020, 0x2020, 0xaaaa, 0x0505,
                0x0202, 0x0202, 0xaaaa, 0x5050, 0x2020, 0x2020, 0xaaaa, 0x0505},
        {0x4040, 0x8080, 0x0000, 0x0808, 0x0404, 0x0202, 0x0000, 0x2020,
                0x4040, 0x8080, 0x0000, 0x0808, 0x0404, 0x0202, 0x0000, 0x2020},
        {0x6606, 0xc6c6, 0xd8d8, 0x1818, 0x8181, 0x8db1, 0x0c33, 0x6000,
                0x6606, 0xc6c6, 0xd8d8, 0x1818, 0x8181, 0x8db1, 0x0c33, 0x6000},
        {0x0000, 0x0000, 0x0400, 0x0000, 0x0010, 0x0000, 0x8000, 0x0000,
                0x0000, 0x0000, 0x0400, 0x0000, 0x0010, 0x0000, 0x8000, 0x0000},
        {0xf8f8, 0x6c6c, 0xc6c6, 0x8f8f, 0x1f1f, 0x3636, 0x6363, 0xf1f1,
                0xf8f8, 0x6c6c, 0xc6c6, 0x8f8f, 0x1f1f, 0x3636, 0x6363, 0xf1f1},
        {0xaaaa, 0x0000, 0x8888, 0x1414, 0x2222, 0x4141, 0x8888, 0x0000,
                0xaaaa, 0x0000, 0x8888, 0x1414, 0x2222, 0x4141, 0x8888, 0x0000},
        {0x0808, 0x0000, 0xaaaa, 0x0000, 0x0808, 0x0000, 0x8888, 0x0000,
                0x0808, 0x0000, 0xaaaa, 0x0000, 0x0808, 0x0000, 0x8888, 0x0000},
        {0x7777, 0x9898, 0xf8f8, 0xf8f8, 0x7777, 0x8989, 0x8f8f, 0x8f8f,
                0x7777, 0x9898, 0xf8f8, 0xf8f8, 0x7777, 0x8989, 0x8f8f, 0x8f8f},
        {0x8080, 0x8080, 0x4141, 0x3e3e, 0x0808, 0x0808, 0x1414, 0xe3e3,
                0x8080, 0x8080, 0x4141, 0x3e3e, 0x0808, 0x0808, 0x1414, 0xe3e3},
        {0x8181, 0x4242, 0x2424, 0x1818, 0x0606, 0x0101, 0x8080, 0x8080,
                0x8181, 0x4242, 0x2424, 0x1818, 0x0606, 0x0101, 0x8080, 0x8080},
        {0xf0f0, 0xf0f0, 0xf0f0, 0xf0f0, 0x0f0f, 0x0f0f, 0x0f0f, 0x0f0f,
                0xf0f0, 0xf0f0, 0xf0f0, 0xf0f0, 0x0f0f, 0x0f0f, 0x0f0f, 0x0f0f},
        {0x0808, 0x1c1c, 0x3e3e, 0x7f7f, 0xffff, 0x7f7f, 0x3e3e, 0x1c1c,
                0x0808, 0x1c1c, 0x3e3e, 0x7f7f, 0xffff, 0x7f7f, 0x3e3e, 0x1c1c},
        {0x1111, 0x2222, 0x4444, 0xffff, 0x8888, 0x4444, 0x2222, 0xffff,
                0x1111, 0x2222, 0x4444, 0xffff, 0x8888, 0x4444, 0x2222, 0xffff}
};

static int get_pattern_id(const uint16_t *pattern)
{
    int result = -1;
    uint16_t *p = (uint16_t *) patterns;
    for (int id = 0; id < 24; id++) {
        // See if first word matches
        int index = id * 16;
        if (p[index] == pattern[0]) {
            // first word matches. See if next 16 match
            int have_match = 1;
            for (int i = 0; i < 16; i++) {
                if (p[index + i] != pattern[i]) {
                    have_match = 0;
                    break;
                }
            }
            if (have_match) {
                result = id;
                break;
            }
        }
    }
    return result;
}

static const char *get_pattern_description(const uint16_t *pattern, int *do_dump)
{
    static char buffer[1000];
    const char *result = "unknown";
    int pattern_id = get_pattern_id(pattern);
    *do_dump = 1;
    if (pattern_id == -1) return result;
    switch (pattern_id) {
        case 3:
            result = "intensity 50%";
            *do_dump = 0;
            break;
        case 7:
            result = "solid pattern";
            *do_dump = 0;
            break;
        default: {
            ksprintf(buffer, "known pattern %d, but unnamed", pattern_id);
            return buffer;
        }
    }
    return result;
}

static void dump_pattern(short *pattern)
{
    for (int i = 0; i < 16; i++) {
        PRINTF(("pattern[%d] = 0x%04x\n", i, pattern[i]));
    }
}

void dump_fill_area_params(long x0, long y0, long w, long h, long colour, long mode, short pattern[])
{
    int16_t fg = (int16_t) (colour & 0xFFFF);
    int16_t bg = (int16_t) ((colour >> 16) & 0xFFFF);
    int do_dump = mode != MODE_XOR;
    PRINTF(("c_fill_area(): x0: %3ld, y0: %3ld, w: %3ld, h: %3ld, col: %ld (bg=0x%04x, fg=0x%04x), mode: %ld (%s)\n",
            x0, y0, w, h, colour, bg, fg, mode, mode2string(mode)));
    const char *desc = get_pattern_description((const uint16_t *) pattern, &do_dump);
    if (do_dump) {
        PRINTF((", pattern id: %s\n", desc));
        dump_pattern(pattern);
    } else {
        PRINTF(("\n"));
    }
}

#endif